# Lecture 2: Relational Databases

1. It is stores in rows and columns
2. The major important part of this is relations.
3. ACID Properties
    - Atomicity
    - Consistency
    - Isolation
    - Durability
4. Indexes make reads faster but writes slower

## Locking (Pessimistic Locking)
1. Whenever we want to update a critical section, a thread acquires access to the critical section and then releases it after the update is done. It protects consistency and Integrity
2. ACQ_LOCK() -> CRITICAL_SECTION -> REL_LOCK()
3. There are two types of locking strategies:
    - Shared Locks
    - Exclusive Locks
4. Pesimistic Locking may lead to deadlocks.
5. Everytime you lock a row, the database runs a deadlock detection algorithm to check if there is a deadlock or not. If there is a deadlock, it will kill one of the transactions and release the locks.
6. Fixed Inventory + Contention = Locking

### Shared Locks
1. These are called read locks
2. We can get a shared lock on a bunch of rows by adding `...  FOR SHARE;`. Whenever the db engine sees this, it allows the transaction to get a shared lock on the rows.
3. When a transaction has acquired a shared lock on a row, it can read the row, other transactions can also read the row but no transaction can write to the row.
4. Read lock gives high read throughput
5. The transaction that has acquired the shared lock can write to the row, but the lock will be upgraded to an exclusive lock. It happens implicitly. Any write transaction will be exclusive lock.

### Exclusive Locks
1. We can get a shared lock on a bunch of rows by adding `...  FOR UPDATE;`. This gives the transaction an exclusive lock on the rows.
2. No other transaction can read or write to the rows that have been locked by the transaction. When a transaction has to read a row that has been locked by another transaction, it will wait for the lock to be released, and once that lock is released, the transaction reevaluates the query and reads the row.
3. We can write `... FOR UPDATE NOWAIT;` to get an exclusive lock on the rows. If the rows are already locked, the transaction will fail. We need this since the transaction will wait indefinitely for the lock to be released.
4. We can write `... FOR UPDATE SKIP LOCKED;` to get an exclusive lock on the rows. If the rows are already locked, the transaction will skip the rows and continue.
5. 